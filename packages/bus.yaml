# This operates under the assumption that you pass in the following:
# MQTT Prefix/topic
# Name of bus
# Script to run when we're the owner

globals:
  - id: pre_psi
    type: float
    restore_value: no
    initial_value: '0'

  - id: bus_psi_increasing
    type: boolean
    restore_value: no
    initial_value: "false"

script:
  - id: receive_bus_request
    mode: parallel
    then:
      - lambda: |-
          json::global_json_buffer.clear();
          std::string array_string = id(bus_queue).state;
          JsonArray& array = json::global_json_buffer.parseArray(array_string);

          array.add(id(bus_request).state);

          std::string new_array_string;
          array.printTo(new_array_string);
          ESP_LOGW(TAG, "Array: %s (%d)\n\n", new_array_string.c_str(), array.size());

          id(bus_queue).publish_state(new_array_string.c_str());
      - script.execute: reserve_bus

  - id: reserve_bus
    mode: queued
    then:
      - logger.log: "Changing bus ownership."
      - script.execute: _bus_timeout
      - mqtt.publish:
          topic: seedship/${system}/bus_owner
          # TODO: Make this persist state by setting the value of bus_queue at boot via another sensor subscribed to bus_queue... Maybe persist message?
          payload: !lambda >-
              json::global_json_buffer.clear();
              std::string array_string = id(bus_queue).state;
              JsonArray& array = json::global_json_buffer.parseArray(array_string);

              std::string request = array[0];
              array.remove(0);

              std::string new_array_string;
              array.printTo(new_array_string);
              ESP_LOGW(TAG, "Array: %s (%d)\n\n", new_array_string.c_str(), array.size());

              id(bus_queue).publish_state(new_array_string.c_str());
              return request;
      # Need to allow for the state to actually change.
      - delay: 1 s
      - wait_until:
          condition:
            text_sensor.state:
              id: bus
              state: "idle"
      - logger.log: "Finished waiting for idle"

      # Clean up the timeout script if it's still running.
      - if:
          condition:
              script.is_running: _bus_timeout
          then:
              script.stop: _bus_timeout

  - id: _bus_timeout
    then:
        - delay:  1 min
        - if:
            condition:
                not:
                  text_sensor.state:
                    id: bus
                    state: "idle"
            then:
                - mqtt.publish:
                    topic: seedship/${system}/warnings
                    payload: "${system}: Bus timed out; Resetting owner to idle."
                - mqtt.publish:
                    topic: seedship/${system}/bus_owner
                    payload: "idle"


text_sensor:
  - platform: mqtt_subscribe
    name: "${system_friendly} Bus"
    id: bus
    topic: seedship/${system}/bus_owner

  - platform: mqtt_subscribe
    name: "${system_friendly} Bus Request"
    id: bus_request
    topic: seedship/${system}/bus_request_access
    on_value:
      - script.execute: receive_bus_request

  - platform: template
    name: ${system_friendly} Bus Queue
    id: bus_queue

esphome:
  on_boot:
    then:
      - script.execute: _bus_timeout