# This operates under the assumption that you pass in the following:
# TODO: Update this?
# MQTT Prefix/topic
# Name of bus
# Script to run when we're the owner

#globals:
#  - id: pre_psi
#    type: float
#    restore_value: no
#    initial_value: '0'
#
#  - id: bus_psi_increasing
#    type: boolean
#    restore_value: no
#    initial_value: "false"

script:
  - id: receive_drainage_bus_request
    mode: parallel
    then:
      - lambda: |-
          json::global_json_buffer.clear();
          std::string array_string = id(drainage_bus_queue).state;
          JsonArray& array = json::global_json_buffer.parseArray(array_string);

          array.add(id(drainage_bus_request).state);

          std::string new_array_string;
          array.printTo(new_array_string);
          //ESP_LOGW(TAG, "Array: %s (%d)\n\n", new_array_string.c_str(), array.size());

          id(drainage_bus_queue).publish_state(new_array_string.c_str());
      - script.execute: reserve_drainage_bus

  - id: reserve_drainage_bus
    mode: queued
    then:
      - logger.log: "Changing drainage bus ownership."
      - script.execute: _drainage_bus_timeout
      - switch.turn_on: drainage_pump
      - mqtt.publish:
          topic: seedship/${system}/drainage_bus_owner
          # TODO: Make this persist state by setting the value of bus_requests at boot via another sensor subscribed to bus_requests... Maybe persist message?
          payload: !lambda >-
              json::global_json_buffer.clear();
              std::string array_string = id(drainage_bus_queue).state;
              JsonArray& array = json::global_json_buffer.parseArray(array_string);

              std::string request = array[0];
              array.remove(0);

              std::string new_array_string;
              array.printTo(new_array_string);
              //ESP_LOGW(TAG, "Array: %s (%d)\n\n", new_array_string.c_str(), array.size());

              id(drainage_bus_queue).publish_state(new_array_string.c_str());
              return request;
      # Need to allow for the state to actually change.
      - delay: 1 s
      - wait_until:
          condition:
            text_sensor.state:
              id: drainage_bus
              state: "idle"
      - logger.log: "Finished waiting for idle"

      # Clean up the timeout script if it's still running.
      - if:
          condition:
              script.is_running: _drainage_bus_timeout
          then:
              script.stop: _drainage_bus_timeout
      - switch.turn_off: drainage_pump

  - id: _drainage_bus_timeout
    then:
        - delay: 14 min
        - if:
            condition:
                not:
                  text_sensor.state:
                    id: drainage_bus
                    state: "idle"
            then:
                - mqtt.publish:
                    topic: seedship/${system}/warnings
                    payload: "${system}: Drainage bus timed out; Resetting owner to idle."
                - mqtt.publish:
                    topic: seedship/${system}/drainage_bus_owner
                    payload: "idle"


text_sensor:
  - platform: mqtt_subscribe
    name: "${system_friendly} Drainage Bus"
    id: drainage_bus
    topic: seedship/${water_supply}/drainage_bus_owner

  - platform: mqtt_subscribe
    name: "${system_friendly} Drainage Bus Requests"
    id: drainage_bus_request
    topic: seedship/${system}/drainage_bus_request_access
    on_value:
      - script.execute: receive_drainage_bus_request

  - platform: template
    name: ${system_friendly} Drainage Bus Queue
    id: drainage_bus_queue


esphome:
  on_boot:
    then:
      - script.execute: _drainage_bus_timeout