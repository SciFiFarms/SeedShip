# This is an unbranded-water-supply-mixer.yaml template. 
substitutions:
  #debug: !debug
  <<: !include templates/generated_substitutions.yaml

script:
  - id: pump_system
    mode: single
    then:
      - logger.log: "Starting Pump System"
      - switch.turn_off: water_line
      - lambda: |-
          id(water).dose();
      - wait_until:
          switch.is_off: water
      - script.execute: repressurize
      - script.wait: repressurize

  - id: drain
    # TODO: This works fine as long as there aren't any conflicts. Once those start happening an actual queue will be needed. 
    # I think the tricky part is going to be getting and storing drainage_bus_request state to give each run a different value. 
    # Basically, how to queue with state. 
    mode: single
    then:
      - logger.log: "Changing drainage bus ownership."
      - mqtt.publish:
          topic: seedship/drainage/owner
          payload: !lambda |-
              return id(drainage_bus_request)->state;
      - switch.turn_on: drainage_pump
      # Have to give the message time to work through the network and get back to this device.q`
      - delay: 10s 
      - wait_until:
          condition:
            text_sensor.state:
              id: drainage_bus
              state: "idle"
      - switch.turn_off: drainage_pump

  - id: repressurize
    mode: single
    then:
      - logger.log: "Repressurizing."
      - script.execute: clear_pump_system
      - wait_until:
          not:
            script.is_running: clear_pump_system
      - if:
          condition:
            sensor.in_range:
              id: bus_psi
              below: 65
          # If it's a fresh batch, it'll take extra long to pressurize.
          then:
            - lambda: 
                # Increase the dose X3.
                id(water_line).dose(3);
          else:
            - lambda: |-
                id(water_line).dose();
      - wait_until:
          switch.is_off: water_line
      - logger.log: "Finished pressurizing."

  - id: clear_pump_system
    mode: single
    then:
      - logger.log: Start clear_pump_system
      - script.execute: _clear_pump_system
      - wait_until:
          not:
            script.is_running: _clear_pump_system
      - logger.log: Finished initial wait for clear_pump_system
      - if:
          condition:
            # TODO: Maybe this should be pump_psi < pump system_psi?
            sensor.in_range:
              id: pump_psi
              below: 65
          then:
            #- script.stop: _clear_pump_system_timeout
            - logger.log: try 2
            - script.execute: _clear_pump_system
      - wait_until:
          not:
            script.is_running: _clear_pump_system
      - logger.log: Finished final wait for clear_pump_system

  # I prepended "_" because it should be thought of as an internal call. 
  # Error handling and timeout detection is handled higher up the stack.  
  - id: _clear_pump_system
    mode: single
    then:
      - if:
          condition:
            sensor.in_range:
              id: pump_psi
              below: 90
          # If it's a fresh batch, it'll take extra long to pressurize.
          then:
            # Increase the dose X3.
            - lambda: |-
                id(discharge).dose(3);
          else:
            - lambda: |-
                id(discharge).dose();
      - delay: !lambda |-
          return id(discharge).get_dosage() - 1000;
      - script.execute: _clear_pump_system_timeout
      - wait_until:
          lambda: 
              return id(bus_psi)->state < id(pump_psi)->state;

  # Stop _clear_pump when the timeout expires. 
  - id: _clear_pump_system_timeout
    mode: single
    then: 
      - delay: 1 min
      - logger.log: "_clear_pump_system_timeout timout done"
      - if:
          condition:
            script.is_running: _clear_pump_system
          then:
            - logger.log: "_clear_system_pump timed out."
            - mqtt.publish:
                topic: seedships/${system}/warnings
                payload: "${system}: clear_pump_system timed out and had to retry."
            - script.stop: _clear_pump_system
      - logger.log: "Finished _clear_pump_system_timeout"

switch:
  # Relay 1
  # Peristaltic Pump
  - platform: dosage
    name: "${system_friendly} Water"
    command_topic: seedship/${system}/water
    pin: 
      number: GPIO15
      mode: OUTPUT
    id: water
    restore_mode: ALWAYS_OFF
    dosage: 30 min

  # Relay 2
  # Solenoid. 
  - platform: dosage
    name: "${system_friendly} Discharge"
    command_topic: seedship/${system}/${subsystem}_discharge
    pin: 
      number: GPIO5
      mode: OUTPUT
    id: discharge
    restore_mode: ALWAYS_OFF
    dosage: 15s

  # Relay 3
  # Solenoid. 
  - platform: dosage
    name: "${system_friendly} Water Line"
    command_topic: seedship/${system}/water_line
    pin: 
      number: GPIO14
      mode: OUTPUT
    id: water_line
    restore_mode: ALWAYS_OFF
    dosage: 5 min

  # Relay 4
  - platform: dosage
    name: "${system_friendly} Drainage Pump"
    command_topic: seedship/${system}/drainage_pump
    pin:
      number: GPIO12
    id: drainage_pump
    restore_mode: ALWAYS_OFF
    dosage: 10 min

  # Relay USB
  - platform: gpio
    name: "${system_friendly} ${subsystem_friendly} Esp32 Power"
    command_topic: seedship/${system}/${subsystem}_esp32_power
    pin: GPIO4
    id: esp32_power
    restore_mode: ALWAYS_ON

binary_sensor:
  - platform: gpio
    pin:
      number: GPIO13
      mode: INPUT_PULLUP
      inverted: True
    name: "${system_friendly} ${subsystem_friendly} Button"
    on_multi_click:
      - timing: 
          - ON for at least 3s
        then:
          - if:
              condition: 
                - lambda: |-
                    return id(mode).state == $MODE_MANUAL_OVERRIDE;
              then:
                - lambda: |-
                    id(mode).publish_state($MODE_RUNNING);
              else:
                - lambda: |-
                    id(mode).publish_state($MODE_MANUAL_OVERRIDE);

      - timing:
          - ON for at most 1s
          - OFF for at most 0.3s
          - ON for at most 1s
          - OFF for at least 0.2s
        then:
          - logger.log: "Double-Clicked"
          - if:
              condition:
                - lambda: |-
                    return id(mode).state == $MODE_RUNNING;
              then:
                - if: 
                    condition:
                      - script.is_running: pump_system
                    then:
                      - logger.log: Already pumping water. Canceling job.
                      - script.stop: pump_system
                      - lambda: |-
                          id(water).cancel_dose();
                          id(discharge).cancel_dose();
                          id(water_line).cancel_dose();
                    else:
                      - script.execute: pump_system

      - timing:
          - ON for at most 1s
          - OFF for at least 0.5s
        then:
          - logger.log: "Single-Clicked"
          - switch.turn_off: water_line
          - lambda: |-
              id(discharge).dose();

  - platform: status
    name: "${system_friendly} ${subsystem_friendly} Status"

sensor:
  - platform: mqtt_subscribe
    id: bus_psi
    topic: seedship/${system}/bus_psi
    on_value:
      - if: 
          condition:
              and:
                  - sensor.in_range:
                      id: bus_psi
                      # This needs to be slightly below the turn on point for the pump.
                      below: 72
                  - switch.is_off: water_line
                  - switch.is_off: water
                  - not:
                    - script.is_running: pump_system
                  - not:
                    - script.is_running: repressurize
                  - not: 
                    - script.is_running: clear_pump_system
                  - lambda: |-
                      return id(mode).state == $MODE_RUNNING;
                  - mqtt.connected:
          then:
            - logger.log: "Opening water_line"
            - script.execute: repressurize
            - script.wait: repressurize
            - logger.log: "water_line closed. "

            # If it's not to pressure by now, a new batch is needed. 
            - if:
                condition:
                  sensor.in_range:
                    below: 90
                    id: bus_psi
                then:
                  - mqtt.publish:
                      # TODO: This should be a sensor reserving the mixing system. 
                      topic: seedship/${system}/strawberries
                      payload: 1

      - if: 
          condition:
              and:
                  - sensor.in_range:
                      id: bus_psi
                      below: 64
                  - not: 
                      script.is_running: pump_system
                  - not: 
                      script.is_running: repressurize
                  - lambda: |-
                      return id(mode).state == $MODE_RUNNING;
                  - mqtt.connected:
          then:
            - mqtt.publish:
                topic: seedship/${system}/strawberries
                payload: 1
            - logger.log: "Starting strawberry delay"
            - delay: 40 min
            - logger.log: "Finished strawberry delay"

  - platform: mqtt_subscribe
    id: pump_psi
    topic: seedship/${system}/pump_psi

  - platform: mqtt_subscribe
    id: strawberry
    topic: seedship/${system}/strawberries
    on_value:
      - if:
          condition:
            - script.is_running: pump_system
          then:
            - logger.log: Already pumping water. Exiting.
          else:
            - logger.log: Running pump_system
            - script.execute: pump_system

  - !include templates/sensor/seedship_mode.yaml
  - platform: wifi_signal
    name: "${system_friendly} ${subsystem_friendly} WiFi Signal"
    update_interval: 60s
  - platform: uptime
    name: "${system_friendly} ${subsystem_friendly} Uptime"

text_sensor:
  - platform: version
    name: "${system_friendly} ${subsystem_friendly} ESPHome Version"  

  - platform: mqtt_subscribe
    name: "${system_friendly} Drainage Bus"
    id: drainage_bus
    topic: seedship/drainage/owner

  - platform: mqtt_subscribe
    name: "${system_friendly} Drainage Bus Requests"
    id: drainage_bus_request
    topic: seedship/drainage/request_access
    on_value: 
      - script.execute: drain

status_led:
  pin:
    number: GPIO2

esphome: !include templates/esphome/esp01_1m.yaml
wifi: !include secrets/wifi.yaml
mqtt: !include templates/mqtt/mqtt.yaml
logger:
ota:
